"Middle" = "#E75480",
"High" = "#B965E1"
)
ggplot(data, aes(x = Cancer_Type, fill = phy_cat)) +
geom_bar(position = "fill") +
scale_fill_manual(values = barbie_palette) +
scale_y_continuous(labels = scales::percent) +
labs(
title = "Physical Activity Level (Proportion) by Cancer Type",
x = "Cancer Type",
y = "Proportion of Patients",
fill = "PA Level"
) +
geom_hline(
yintercept = 0.18,
linetype = "dashed",
color = "black",
linewidth = 0.6
) +
theme_minimal()
print(chi_sq_result <- chisq.test(contingency_table))
library(MASS)
data$Cancer_Type <- as.factor(data$Cancer_Type)
Ordinary_Log_Reg <- MASS::polr(
phy_cat ~ Cancer_Type,
data = data,
Hess = TRUE
)
summary(Ordinary_Log_Reg)
library(emmeans)
post_test <- emmeans(Ordinary_Log_Reg, specs = "Cancer_Type")
pairwise_comparison <- pairs(post_test, adjust = "holm")
summary(pairwise_comparison)
library(emmeans)
library(ggplot2)
library(emmeans)
post_test <- emmeans(Ordinary_Log_Reg, specs = "Cancer_Type")
pairwise_comparison <- pairs(post_test, adjust = "holm")
emmeans_plot <- plot(post_test, comparisons = TRUE) +
labs(
title = "Comparison of Physical Activity Levels by Cancer Type",
x = "Latent Physical Activity Score (Higher = More Active)",
y = "Cancer Type"
) +
theme_minimal()
print(emmeans_plot)
library(knitr)
library(kableExtra)
install.packages("kableExtra")
library(knitr)
library(kableExtra)
# 1. Create the data frame cleanly
codebook_data <- data.frame(
Variable_Name = c("Physical_Activity_Level",
"phy_cat",
"Cancer_Type",
"Overall_Risk_Score",
"Diet_Red_Meat",
"Fruit_Veg_Intake"),
Role = c("Raw Input (RQ1)",
"Dependent Variable (Outcome) (RQ1)",
"Independent Variable (RQ1, RQ3)",
"Dependent Variable (Outcome) (RQ2)",
"Independent Variable (RQ2)",
"Moderator (Interaction) (RQ2)"),
Recoding = c("None. Continuous integer scale (1-10).",
"Categorical Binning: Low (1-3), Middle (4-7), High (8-10). Converted to ordered factor.",
"Factorization: Converted from string to factor.",
"None. Continuous numeric.",
"None. Continuous numeric.",
"Categorical Binning: Low (0-2), Medium (3-5), High (6-8)."),
Missing_Values = c("None", "None", "None", "None", "None", "None")
)
# 2. Render the table with text wrapping
kable(codebook_data,
col.names = c("Variable Name", "Role in Analysis", "Recoding / Treatment", "Missing Values"),
booktabs = TRUE,
caption = "Codebook of Selected Variables") %>%
kable_styling(latex_options = c("hold_position", "striped")) %>%
column_spec(1, width = "3cm") %>%   # Fixes the first column width
column_spec(2, width = "3cm") %>%   # Fixes the Role column
column_spec(3, width = "6cm") %>%   # Gives the most space to Recoding
column_spec(4, width = "2cm")       # Keeps Missing Values narrow
library(knitr)
library(kableExtra)
# 1. Create the data frame cleanly
codebook_data <- data.frame(
Variable_Name = c("Physical_Activity_Level",
"phy_cat",
"Cancer_Type",
"Overall_Risk_Score",
"Diet_Red_Meat",
"Fruit_Veg_Intake"),
Role = c("Raw Input (RQ1)",
"Dependent Variable (Outcome) (RQ1)",
"Independent Variable (RQ1, RQ3)",
"Dependent Variable (Outcome) (RQ2)",
"Independent Variable (RQ2)",
"Moderator (Interaction) (RQ2)"),
Recoding = c("None. Continuous integer scale (1-10).",
"Categorical Binning: Low (1-3), Middle (4-7), High (8-10). Converted to ordered factor.",
"Factorization: Converted from string to factor.",
"None. Continuous numeric.",
"None. Continuous numeric.",
"Categorical Binning: Low (0-2), Medium (3-5), High (6-8)."),
Missing_Values = c("None", "None", "None", "None", "None", "None")
)
# 2. Render the table with text wrapping
kable(codebook_data,
col.names = c("Variable Name", "Role in Analysis", "Recoding / Treatment", "Missing Values"),
booktabs = TRUE,
caption = "Codebook of Selected Variables") %>%
kable_styling(latex_options = c("hold_position", "striped")) %>%
column_spec(1, width = "3cm") %>%   # Fixes the first column width
column_spec(2, width = "3cm") %>%   # Fixes the Role column
column_spec(3, width = "6cm") %>%   # Gives the most space to Recoding
column_spec(4, width = "2cm")       # Keeps Missing Values narrow
View(test_df)
knitr::opts_chunk$set(echo = TRUE)
# Define the Transition Matrix A
# Row 1: From Guarding -> (Guarding, Sleeping)
# Row 2: From Sleeping -> (Guarding, Sleeping)
A <- matrix(c(0.9, 0.1,
0.4, 0.6),
nrow = 2,
byrow = TRUE)
# Label the rows and columns for clarity
rownames(A) <- c("Guard", "Sleep")
colnames(A) <- c("Guard", "Sleep")
# Display the matrix
print(A)
# Define the Transition Matrix A
# Row 1: From Guarding -> (Guarding, Sleeping)
# Row 2: From Sleeping -> (Guarding, Sleeping)
A <- matrix(c(0.98, 0.02,
0.4, 0.6),
nrow = 2,
byrow = TRUE)
# Label the rows and columns for clarity
rownames(A) <- c("Awake", "Sleep")
colnames(A) <- c("Awake", "Sleep")
# Display the matrix
print(A)
# Define the Transition Matrix A
# Row 1: From Guarding -> (Guarding, Sleeping)
# Row 2: From Sleeping -> (Guarding, Sleeping)
A <- matrix(c(0.98, 0.02,
0.4, 0.6),
nrow = 2,
byrow = TRUE)
# Label the rows and columns for clarity
rownames(A) <- c("Awake", "Sleep")
colnames(A) <- c("Awake", "Sleep")
# Display the matrix
print(A)
# Define the Emission Matrix B
# Row 1: If Guarding -> chance of hearing (Money, Snore)
# Row 2: If Sleeping -> chance of hearing (Money, Snore)
B <- matrix(c(0.8, 0.2,
0.1, 0.9),
nrow = 2,
byrow = TRUE)
# Label the rows (Hidden States) and columns (Observations)
rownames(B) <- c("Guard", "Sleep")
colnames(B) <- c("Money", "Snore")
# Display the matrix
print(B)
# Define the Emission Matrix B
# Row 1: If Guarding -> chance of hearing (Money, Snore)
# Row 2: If Sleeping -> chance of hearing (Money, Snore)
B <- matrix(c(0.8, 0.2,
0.1, 0.9),
nrow = 2,
byrow = TRUE)
# Label the rows (Hidden States) and columns (Observations)
rownames(B) <- c("Awake", "Snore")
colnames(B) <- c("Money", "Snore")
# Display the matrix
print(B)
# Define the Emission Matrix B
# Row 1: If Guarding -> chance of hearing (Money, Snore)
# Row 2: If Sleeping -> chance of hearing (Money, Snore)
B <- matrix(c(0.8, 0.2,
0.1, 0.9),
nrow = 2,
byrow = TRUE)
# Label the rows (Hidden States) and columns (Observations)
rownames(B) <- c("Awake", "Snore")
colnames(B) <- c("Awake", "Snore")
# Display the matrix
print(B)
# Define the Emission Matrix B
# Row 1: If Guarding -> chance of hearing (Money, Snore)
# Row 2: If Sleeping -> chance of hearing (Money, Snore)
B <- matrix(c(0.8, 0.2,
0.1, 0.9),
nrow = 2,
byrow = TRUE)
# Label the rows (Hidden States) and columns (Observations)
rownames(B) <- c("Talk", "Snore")
colnames(B) <- c("Talk", "Snore")
# Display the matrix
print(B)
# Define the Emission Matrix B with Conditional Probabilities
# Rows = Hidden States (Awake, Sleep)
# Cols = Observations (Pearl, Snore)
B <- matrix(c(
# Row 1: Awake
0.8,  # P(Pearl | Awake)  - Talking to daughter
0.2,  # P(Snore | Awake)  - Faking it to trap Plankton
# Row 2: Sleep
0.1,  # P(Pearl | Sleep)  - Mumbling in sleep
0.9   # P(Snore | Sleep)  - Actually sleeping
),
nrow = 2,
byrow = TRUE)
# Label the rows and columns
rownames(B) <- c("Awake", "Sleep")
colnames(B) <- c("Pearl", "Snore")
# Display the matrix
print(B)
# Define the Emission Matrix B with Conditional Probabilities
# Rows = Hidden States (Awake, Sleep)
# Cols = Observations (Pearl, Snore)
# Create a data frame for the Conditional Probabilities
prob_chart <- data.frame(
Hidden_State = c("Awake", "Awake", "Sleep", "Sleep"),
Observation = c("Pearl", "Snore", "Pearl", "Snore"),
Probability = c(0.8, 0.2, 0.1, 0.9),
Meaning = c("Talking on phone", "Faking a snore (Trick)", "Mumbling (Error)", "Actually sleeping")
)
# Print the chart nicely
knitr::kable(prob_chart, caption = "Conditional Probability Chart (Emission Matrix)")
B <- matrix(c(
# Row 1: Awake
0.8,  # P(Pearl | Awake)  - Talking to daughter
0.2,  # P(Snore | Awake)  - Faking it to trap Plankton
# Row 2: Sleep
0.1,  # P(Pearl | Sleep)  - Mumbling in sleep
0.9   # P(Snore | Sleep)  - Actually sleeping
),
nrow = 2,
byrow = TRUE)
# Label the rows and columns
rownames(B) <- c("Awake", "Sleep")
colnames(B) <- c("Pearl", "Snore")
# Display the matrix
print(B)
# --- 1. SETUP THE MATRICES ---
# We redefine them here to ensure the simulation is self-contained
# Matrix A: Transition Probabilities (Hidden Layer)
# Awake -> Awake (0.9), Awake -> Sleep (0.1)
# Sleep -> Awake (0.4), Sleep -> Sleep (0.6)
A <- matrix(c(0.9, 0.1,
0.4, 0.6), nrow = 2, byrow = TRUE)
rownames(A) <- c("Awake", "Sleep")
colnames(A) <- c("Awake", "Sleep")
# Matrix B: Emission Probabilities (Observation Layer)
# Awake -> Pearl (0.8), Snore (0.2 - Trick)
# Sleep -> Pearl (0.1 - Mumble), Snore (0.9 - Real)
B <- matrix(c(0.8, 0.2,
0.1, 0.9), nrow = 2, byrow = TRUE)
rownames(B) <- c("Awake", "Sleep")
colnames(B) <- c("Pearl", "Snore")
# --- 2. RUN THE SIMULATION ---
set.seed(101) # Set seed for reproducible results
minutes <- 20
states <- c("Awake", "Sleep")
sounds <- c("Pearl", "Snore")
# Storage vectors
true_state <- character(minutes)
observed_sound <- character(minutes)
# Start the simulation: Mr. Krabs starts Awake
true_state[1] <- "Awake"
# Generate the first sound based on the first state
observed_sound[1] <- sample(sounds, 1, prob = B["Awake", ])
for(t in 2:minutes){
# Step 1: Determine NEXT state based on PREVIOUS state (Matrix A)
prev <- true_state[t-1]
true_state[t] <- sample(states, 1, prob = A[prev, ])
# Step 2: Determine SOUND based on CURRENT state (Matrix B)
curr <- true_state[t]
observed_sound[t] <- sample(sounds, 1, prob = B[curr, ])
}
# --- 3. ANALYZE RESULTS ---
# Combine into a data frame
simulation_df <- data.frame(
Time = 1:minutes,
Reality = true_state,
Heard = observed_sound
)
# Identify "Errors" where Plankton might get tricked
# (e.g., Heard "Snore" but Reality was "Awake")
simulation_df$Status <- ifelse(
(simulation_df$Reality == "Awake" & simulation_df$Heard == "Snore") |
(simulation_df$Reality == "Sleep" & simulation_df$Heard == "Pearl"),
"TRICKED!", "Correct")
# Print the table
knitr::kable(simulation_df, caption = "Simulation of 20 Minutes at the Krusty Krab")
# Create a data frame for the Conditional Probabilities (for the pretty table)
prob_chart <- data.frame(
Hidden_State = c("Awake", "Awake", "Sleep", "Sleep"),
Observation = c("Pearl", "Snore", "Pearl", "Snore"),
Probability = c(0.8, 0.2, 0.1, 0.9),
Meaning = c("Talking on phone", "Faking a snore (Trick)", "Mumbling (Error)", "Actually sleeping")
)
# Print the chart nicely
knitr::kable(prob_chart, caption = "Conditional Probability Chart (Emission Matrix)")
# Define the Emission Matrix B for calculations
B <- matrix(c(0.8, 0.2,
0.1, 0.9),
nrow = 2,
byrow = TRUE)
rownames(B) <- c("Awake", "Sleep")
colnames(B) <- c("Pearl", "Snore")
# Display the matrix
print(B)
# Create a data frame for the Conditional Probabilities (for the pretty table)
prob_chart <- data.frame(
Hidden_State = c("Awake", "Awake", "Sleep", "Sleep"),
Observation = c("Pearl", "Snore", "Pearl", "Snore"),
Probability = c(0.8, 0.2, 0.1, 0.9),
Meaning = c("Talking on phone", "Faking a snore (Trick)", "Mumbling (Error)", "Actually sleeping")
)
# Print the chart nicely
knitr::kable(prob_chart, caption = "Conditional Probability Chart (Emission Matrix)")
# Define the Emission Matrix B for calculations
B <- matrix(c(0.8, 0.2,
0.1, 0.9),
nrow = 2,
byrow = TRUE)
rownames(B) <- c("Awake", "Sleep")
colnames(B) <- c("Pearl", "Snore")
# Display the matrix
print(B)
# Define the Transition Matrix A
# Row 1: From Guarding -> (Guarding, Sleeping)
# Row 2: From Sleeping -> (Guarding, Sleeping)
A <- matrix(c(0.98, 0.02,
0.4, 0.6),
nrow = 2,
byrow = TRUE)
# Label the rows and columns for clarity
rownames(A) <- c("Awake", "Sleep")
colnames(A) <- c("Awake", "Sleep")
# Display the matrix
print(A)
# Create a data frame for the Conditional Probabilities (for the pretty table)
prob_chart <- data.frame(
Hidden_State = c("Awake", "Awake", "Sleep", "Sleep"),
Observation = c("Pearl", "Snore", "Pearl", "Snore"),
Probability = c(0.8, 0.2, 0.1, 0.9),
Meaning = c("Talking on phone", "Faking a snore (Trick)", "Mumbling (Error)", "Actually sleeping")
)
# Print the chart nicely
knitr::kable(prob_chart, caption = "Conditional Probability Chart (Emission Matrix)")
# Define the Emission Matrix B for calculations
B <- matrix(c(0.8, 0.2,
0.1, 0.9),
nrow = 2,
byrow = TRUE)
rownames(B) <- c("Awake", "Sleep")
colnames(B) <- c("Pearl", "Snore")
# Display the matrix
print(B)
rm = ls()
rm = ls()
(rm = ls())
(rm = ls("mse")
install packages("WDI")
install.package("WDI")
install.packages("WDI")
library(WDI)
WDIsearch("gdp")
WDIsearch("gdp PPP")
country_list = c('Comoros', 'Dijbouti', 'Mauritania', 'Sudan', 'Yemen')
country_list = list('Comoros', 'Dijbouti', 'Mauritania', 'Sudan', 'Yemen')
data = WDI(indicator = 'NY.GDP.MKTP.PP.KD', country = c('Turkey'))
install.packages("WDI")
library(WDI)
data = WDI(indicator = 'NY.GDP.MKTP.PP.KD', country = c('Turkey'))
data = WDI(indicator = 'NY.GDP.MKTP.PP.KD', country = c('Turkey'))
data = WDI(indicator = 'NY.GDP.MKTP.PP.KD', country = c('ATA'))
data = WDI(indicator = 'NY.GDP.MKTP.PP.KD', country = c('ATA'))
data = WDI(indicator = 'NY.GDP.MKTP.PP.KD', country = c('ALB'))
data = WDI(indicator = 'NY.GDP.MKTP.PP.KD', country = c('ALB'))
git remote add origin https://github.com/s2579/GDP-Data-Analysis.git
git init
library(tidyverse)
library(countrycode)
setwd("'/Users/swim/Desktop/My Projectss/Data_analysis_Cleaning'")
library(tidyverse)
library(countrycode)
setwd("/Users/swim/Desktop/My Projectss/Data_analysis_Cleaning")
#Accessing the CSV file
GDP_PPP <- read.csv("GDP_PPP.csv")
Rule_of_Law <- read.csv("Rule_of_law.csv")
Ranking <- read.csv("Rankings.csv")
#First task: create a Primary key
#Ranking dataset does not have ISO-3 value, so we'll create one for her.
Ranking$iso3 <- countrycode(Ranking$Economy,
origin = 'country.name',
destination = 'iso3c')
#Replace string 'S' with 'ARM'
GDP_PPP$Country.Code[GDP_PPP$Country.Code == 'S'] <- 'ARM'
#Update Kosovo ISO-3
Ranking$iso3[is.na(Ranking$iso3)] <- 'XKX'
#Remove aggregrates in rule of law and GDP_PPP
cleaned_GDP_PP <- GDP_PPP %>%
filter(nchar(Country.Code) == 3) %>%
filter(Country.Code %in% codelist$iso3c | Country.Code == 'XKX') %>%
filter()
cleaned_Rule_of_Law <- Rule_of_Law %>%
filter(nchar(Country.Code) == 3) %>%
filter(Country.Code %in% codelist$iso3c | Country.Code == 'XKX')
updated_GDP_PPP <- rename(cleaned_GDP_PP, iso3 = Country.Code)
updated_ruleoflaw <- rename(cleaned_Rule_of_Law, iso3 = Country.Code)
new_dataset <- merge(updated_GDP_PPP, updated_ruleoflaw, by = "iso3")
new_dataset2 <- merge(new_dataset, Ranking, by = "iso3")
#Clean new_dataset2
#Vector with all coloumns to be removed
remove_these <- c("Indicator.Code.x", "Indicator.Code.y", "Indicator.Name.x",
"Indicator.Name.y", "Country.Name.y", "X.y","X.x" , "Economy", "X2024.y" )
#Use Index to exlcude values listed above
new_dataset2 <- new_dataset2[, !names(new_dataset2) %in% remove_these]
years_update <- str_c("X",as.character(1990:1995))
new_dataset2 <- new_dataset2 %>% rename_with(~paste0(.,".x"), all_of(years_update))
#Remove lichestein (missing values)
new_dataset2 <- new_dataset2[-100,]
#Log GDP PPP 2021
new_dataset2 <- new_dataset2 %>%
mutate(across(matches("\\d{4}.x"), ~ log(.)))
#Convert the "DB 2020 Ranking" into index score
new_dataset2 <- new_dataset2 %>%
mutate(indexed = 1 - (globalRank/189))
#Rule of Law transformation
new_dataset2 <- new_dataset2 %>%
mutate(across(matches("\\d{4}.y"), ~./100))
#Dummy Variable for Oil Endowed Nations
oil_endowed_nations <- c(
"DZA", "BHR", "IRN", "IRQ", "KWT", "LBY", "OMN", "QAT",
"SAU", "ARE", "VEN", "GUY", "MEX", "COL",
"RUS", "KAZ", "AZE", "NOR", "NGA", "AGO",
"GAB", "GNQ")
#Create a new coloumn assigning 1 to oil endowed nations and 0 to others
new_dataset2 <- new_dataset2 %>%
mutate(Oil_Endowed = case_when(
iso3 %in% oil_endowed_nations ~ 1,
!(iso3 %in% oil_endowed_nations) ~ 0
))
Ranking$iso3 <- countrycode(Ranking$Economy,
origin = 'country.name',
destination = 'iso3c')
library(tidyverse)
library(countrycode)
setwd("/Users/swim/Desktop/My Projectss/Data_analysis_Cleaning")
#Accessing the CSV file
GDP_PPP <- read.csv("GDP_PPP.csv")
Rule_of_Law <- read.csv("Rule_of_law.csv")
Ranking <- read.csv("Rankings.csv")
#First task: create a Primary key
#Ranking dataset does not have ISO-3 value, so we'll create one for her.
Ranking$iso3 <- countrycode(Ranking$Economy,
origin = 'country.name',
destination = 'iso3c')
#Replace string 'S' with 'ARM'
GDP_PPP$Country.Code[GDP_PPP$Country.Code == 'S'] <- 'ARM'
#Update Kosovo ISO-3
Ranking$iso3[is.na(Ranking$iso3)] <- 'XKX'
#Remove aggregrates in rule of law and GDP_PPP
cleaned_GDP_PP <- GDP_PPP %>%
filter(nchar(Country.Code) == 3) %>%
filter(Country.Code %in% codelist$iso3c | Country.Code == 'XKX') %>%
filter()
cleaned_Rule_of_Law <- Rule_of_Law %>%
filter(nchar(Country.Code) == 3) %>%
filter(Country.Code %in% codelist$iso3c | Country.Code == 'XKX')
updated_GDP_PPP <- rename(cleaned_GDP_PP, iso3 = Country.Code)
updated_ruleoflaw <- rename(cleaned_Rule_of_Law, iso3 = Country.Code)
new_dataset <- merge(updated_GDP_PPP, updated_ruleoflaw, by = "iso3")
new_dataset2 <- merge(new_dataset, Ranking, by = "iso3")
#Clean new_dataset2
#Vector with all coloumns to be removed
remove_these <- c("Indicator.Code.x", "Indicator.Code.y", "Indicator.Name.x",
"Indicator.Name.y", "Country.Name.y", "X.y","X.x" , "Economy", "X2024.y" )
#Use Index to exlcude values listed above
new_dataset2 <- new_dataset2[, !names(new_dataset2) %in% remove_these]
years_update <- str_c("X",as.character(1990:1995))
new_dataset2 <- new_dataset2 %>% rename_with(~paste0(.,".x"), all_of(years_update))
#Remove lichestein (missing values)
new_dataset2 <- new_dataset2[-100,]
#Log GDP PPP 2021
new_dataset2 <- new_dataset2 %>%
mutate(across(matches("\\d{4}.x"), ~ log(.)))
#Convert the "DB 2020 Ranking" into index score
new_dataset2 <- new_dataset2 %>%
mutate(indexed = 1 - (globalRank/189))
#Rule of Law transformation
new_dataset2 <- new_dataset2 %>%
mutate(across(matches("\\d{4}.y"), ~./100))
#Dummy Variable for Oil Endowed Nations
oil_endowed_nations <- c(
"DZA", "BHR", "IRN", "IRQ", "KWT", "LBY", "OMN", "QAT",
"SAU", "ARE", "VEN", "GUY", "MEX", "COL",
"RUS", "KAZ", "AZE", "NOR", "NGA", "AGO",
"GAB", "GNQ")
#Create a new coloumn assigning 1 to oil endowed nations and 0 to others
new_dataset2 <- new_dataset2 %>%
mutate(Oil_Endowed = case_when(
iso3 %in% oil_endowed_nations ~ 1,
!(iso3 %in% oil_endowed_nations) ~ 0
))
